# ADD:
# loops
# negative numbers
# color
# if statements
# comparison
# functions
# variables
# arrays
# lists
import xml.etree.ElementTree as ET
from clang.cindex import Index, CursorKind, Config
from datetime import datetime

from block_args import block_args
from function_data import block_names

c_file_path = '/home/luna/src/c-to-roboblocky/example.c'
save_path = '/home/luna/Downloads'

block_data_path = './block_data.py'

Config.set_library_file("/usr/lib64/libclang.so.17.0.6")
index = Index.create()
tu = index.parse(c_file_path)

def attach_block(parent_block, child_block):
    element_next = ET.SubElement(parent_block, 'next')
    element_next.append(child_block)
    return child_block

def traverse_node(node):
    global current_block
    next_block = build_block(node)

    if next_block is not None:
        current_block = attach_block(current_block, next_block)
    else:
        for child in node.get_children():
            traverse_node(child)
    
# searches node.kind to determine what function to build with
def build_block(node):
    tokens = list(node.get_tokens())
    match node.kind:
        case CursorKind.INTEGER_LITERAL:
            return build_block_xml('math_number', tokens[0].spelling)
        case CursorKind.CALL_EXPR:
            return build_expression(node)
        case CursorKind.BINARY_OPERATOR:
            return build_binary_operator(node)
        case _:
            return None

# creates function block from expression
def build_expression(node):
    args = []
    block_type = None

    for child in node.get_children():
        tokens = list(child.get_tokens())
        if child.kind == CursorKind.MEMBER_REF_EXPR:
            block_data = block_names[tokens[2].spelling]
            block_type = block_data.type
            if block_data.dropdown: args.append(tokens[2].spelling)
            print(f"Method called: {tokens[2].spelling}")
        elif child.kind == CursorKind.UNEXPOSED_EXPR:
            block_data = block_names[tokens[0].spelling]
            block_type = block_data.type
            if block_data.dropdown:
                args.append(tokens[0].spelling)
            print(f"Method called: {tokens[0].spelling}")
        else:
            args.append(build_block(child))    

    return build_block_xml(block_type, *args)

def build_binary_operator(node):
    arithmetic_operators = {"+": "ADD", "-": "MINUS", "*": "MULTIPLY", "/": "DIVIDE"}
    operator = list(node.get_tokens())[1].spelling
    operands = [build_block(operand) for operand in node.get_children()]
    
    if operator in arithmetic_operators:
        return build_block_xml('math_arithmetic', arithmetic_operators[operator], operands[0], operands[1])
    raise ValueError("TODO: add other binary operators")

# args is list of nodes
def build_block_xml(block_type, *args):
    block_info = block_args.get(block_type)
    if not block_info:
        raise ValueError(f"Block type '{block_type}' not found.")
    if not len(args) == len(block_info):
        raise TypeError(f"'{block_type}'() takes {len(block_info)} argument{'s' if len(block_info) > 1 else ''}, but recieved {len(args)}.")

    block = ET.Element('block', type=block_type)

    for (key, arg_type), arg_value in zip(block_info.items(), args):
        if arg_type == "field":
            field_element = ET.SubElement(block, 'field', name=key)
            field_element.text = str(arg_value)
        elif arg_type == "value":
            value_element = ET.SubElement(block, 'value', name=key)
            value_element.append(arg_value)
        else:
            raise TypeError(f"Argument type '{arg_type}' unknown.")
    return block

### MAIN ###
root = ET.Element('xml', xmlns='http://www.w3.org/1999/xhtml')
current_block = build_block_xml('text_comment', 'Generated with Luna\'s C-to-RoboBlocky transpiler v0.1')
root.append(current_block)
traverse_node(tu.cursor)

### Saving XML tree as file ### 
root.insert(0, ET.Comment(" RoboBlockly hash lines color: #FFFFFF "))
root.insert(0, ET.Comment(" RoboBlockly tics lines color: #FFFFFF "))
root.insert(0, ET.Comment(" RoboBlockly background color: #FFFFFF "))
root.insert(0, ET.Comment(f" RoboBlockly grid: [{0}, {10}] by [{0}, {10}] "))
root.insert(0, ET.Comment(" RoboBlockly gridView: Large View "))
root.insert(0, ET.Comment(" Code generated by RoboBlockly v2.5 "))

xml_tree = ET.ElementTree(root)
ET.indent(xml_tree, space='  ', level=0)
xml_tree.write(f'{save_path}/convert.xml', encoding='utf-8')
print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] XML file generated.")