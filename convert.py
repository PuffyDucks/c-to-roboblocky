import xml.etree.ElementTree as ET
from clang.cindex import Index, CursorKind, Config
from datetime import datetime

from block_args import block_args
from function_data import block_names

c_file_path = '/home/luna/src/py-to-roboblocky/example.c'
save_path = '/home/luna/Downloads'

block_data_path = './block_data.py'

Config.set_library_file("/usr/lib64/libclang.so.17.0.6")
index = Index.create()
tu = index.parse(c_file_path)

def create_block(block_type, *args):
    block_info = block_args.get(block_type)
    if not block_info:
        raise ValueError(f"Block type '{block_type}' not found.")
    if not len(args) == len(block_info):
        raise TypeError(f"'{block_type}'() takes {len(block_info)} argument{'s' if len(block_info) > 1 else ''}, but recieved {len(args)}.")

    block = ET.Element('block', type=block_type)

    for (key, arg_type), arg_value in zip(block_info.items(), args):
        if arg_type == "field":
            field_elem = ET.SubElement(block, 'field', name=key)
            field_elem.text = str(arg_value)

        elif arg_type.startswith("value:"):
            value_block_type = arg_type.split(":")[1]
            value_elem = ET.SubElement(block, 'value', name=key)
            value_elem.append(create_block(value_block_type, arg_value))

    return block

def attach_block(parent_block, child_block):
    element_next = ET.SubElement(parent_block, 'next')
    element_next.append(child_block)
    return child_block

def create_expr(node):
    args = []
    global current_block

    for child in node.get_children():
        tokens = list(child.get_tokens())
        if child.kind == CursorKind.DECL_REF_EXPR:
            print(f"Method called: {tokens[0].spelling}")  

        if child.kind == CursorKind.MEMBER_REF_EXPR:
            # TODO: function name as 1st arg if dropdown=true
            print(f"Method called: {tokens[2].spelling}")
            block_type = block_names[tokens[2].spelling]

        if child.kind == CursorKind.INTEGER_LITERAL:
            args.append(tokens[0].spelling)
    
    next_block = create_block(block_type, *args)
    current_block = attach_block(current_block, next_block)

def traverse_node(node):
    if node.kind == CursorKind.CALL_EXPR:
      create_expr(node)
      return;

    for child in node.get_children():
        traverse_node(child)

### MAIN ###
root = ET.Element('xml', xmlns='http://www.w3.org/1999/xhtml')
current_block = create_block('draw_line', 'line', 1, 2, 3, 4)
root.append(current_block)

traverse_node(tu.cursor)

# next_block = create_block('draw_line', 'line', 5, 6, 7, 8)
# current_block = attach_block(current_block, next_block)

#
# check for:
#   operations
#   functions
#   conditionals/loops
#   data types
#

### Saving XML tree as file ### 
root.insert(0, ET.Comment(" RoboBlockly hash lines color: #FFFFFF "))
root.insert(0, ET.Comment(" RoboBlockly tics lines color: #FFFFFF "))
root.insert(0, ET.Comment(" RoboBlockly background color: #FFFFFF "))
root.insert(0, ET.Comment(f" RoboBlockly grid: [{0}, {10}] by [{0}, {10}] "))
root.insert(0, ET.Comment(" RoboBlockly gridView: Large View "))
root.insert(0, ET.Comment(" Code generated by RoboBlockly v2.5 "))

xml_tree = ET.ElementTree(root)
ET.indent(xml_tree, space='  ', level=0)
xml_tree.write(f'{save_path}/convert.xml', encoding='utf-8')
print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] XML file generated.")